Jared Perreault
November 19, 2015
Programming with Sockets Assignment

fromTerminal() from both (myclient.py and myserver.py):
Both my client and server files contain a function called “fromTerminal”, which is responsible for validating all the command line arguments passed to the client and server. The function utilizes the sys module for its argv function. It also uses the re module, to use regular expressions to validate the inputs. 

runClient(dest, port, gp, file) from myclient.py:
The function takes the inputs passed to it from the fromTerminal function mentioned above. It uses these inputs form a request (at line 65). Then a socket instance is created, connects to the dest/port and sends the requests to the destination. At line 90, GET or PUT request specific code is executed. The request specific code dictates the behavior of how the response and data is received. The GET request simply loops until no more data is received. The PUT request is slightly more complicated. It waits a custom “ACK” from the server, then sends the file to the server via the same connection, until EOF is reached. After the file is finished sending, the client waits for the server's response (this is intended to be the HTTP response code: 200, 404, or 500). 

runServer(port) from myserver.py:
The function takes the port number from the fromTerminal function. The function starts off with getting the IP address of the local machine (this is usually 127.0.1.1). Then a socket instance is created and is bound to the local IP and the given port number. The server then listens on that port number. At line 63 the server enters a infinite while loop, continuously listening to requests and responding to them. On line 65, the Socket.accept() method establishes a new TCP connection on a different port number, to making the server non-blocking. The server then parses the request, handling both GET and PUT requests differently. The handling of GET requests goes as followed: If the file name is “/”, simply return “200 OK  HELLO WORLD!”. If the file name is a real file name, the existence of the file is checked by the os.path module. If the file DOES exist, it's send to the client. If an error occurs during this process, a 500 code is returned to the client. If the file or path DOES NOT exist, a 404 error code is sent. The PUT request is handled similarly. First the server sends an “ACK” to the client, to signal the client to begin sending the file. The server then opens a file stream with the same file name, but places it in the putdata directory (in order to prove that the server does actually work). The server writes all the data to the file stream. Once the file is completed reached it sends a 200 OK FILE CREATED response to the client. Then the secondary connection is closed and the server continues listening.
Design Trade-offs:
The only significant design decision I feel I made was choosing to the Server send an “ACK” to the Client during PUT requests. I didn't want the Client to send an entire file, only to have it all rejected. I believe all other decisions I made are standard with this sort of assignment.
